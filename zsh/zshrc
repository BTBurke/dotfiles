# Path to your oh-my-zsh installation.
export ZSH=$HOME/.oh-my-zsh
export DEFAULT_HOST=$(hostname -f)
export LSCOLORS="dxfxcxdxbxegedabagacad" #set dir color=yellow
export TERM="xterm-256color"

# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
ZSH_THEME="burke"

# add bash emulation to set up snaps
emulate sh -c 'source /etc/profile'

function snap-desktop-shortcuts() {
  cp /var/lib/snapd/desktop/applications/*.desktop ~/.local/share/applications
}

function fix-network() {
  sudo route add -net 0.0.0.0 gw 10.0.0.1 wlp3s0
}

function fix-spotify() {
  sudo sed -i --follow-symlinks 's/spotify %U$/spotify --force-device-scale-factor=2.0 %U/g' /var/lib/snapd/desktop/applications/spotify_spotify.desktop
}
function fix-zoom() {
  sudo sed -i --follow-symlinks 's/\/usr\/bin\/zoom %U$/env QT_DEVICE_PIXEL_RATIO=2 \/usr\/bin\/zoom %U/g' /usr/share/applications/Zoom.desktop
}
#function vpn {
#  if [ "$1" = "cities" ]; then
#    nordvpn cities United_States
#    return 0
#  fi

#  if [ "$1" = "disc" ] || [ "$1" = "kill" ] || [ "$1" = "disconnect" ]; then
#    nordvpn disconnect
#  else
#    nordvpn connect United_States $1
#  fi
#}
#
function vpn() {
  if [ "$1" = "up" ]; then
    link="$2"
    nmcli c up ${link:u}
    return 0
  fi

  if [ "$1" = "down" ] || [ "$1" = "kill" ] || [ "$1" = "disc" ]; then
    nmcli c down $(nmcli c | grep vpn | grep wlp | cut -d ' ' -f 1)
    return 0
  fi

  if [ "$1" = "list" ] || [ "$1" = "" ]; then
    nmcli c | grep vpn | cut -d ' ' -f 1
    return 0
  fi

  if [ "$1" = "--help" ]; then 
    echo "vpn up <city> | down | list"
    return 0
  fi

  echo "unknown command $1.  Usage:\nvpn up <city> | down | list"
}

# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to disable bi-weekly auto-update checks.
# DISABLE_AUTO_UPDATE="true"

# Uncomment the following line to change how often to auto-update (in days).
# export UPDATE_ZSH_DAYS=13

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to disable command auto-correction.
# DISABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# The optional three formats: "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
plugins=(autojump)

source $ZSH/oh-my-zsh.sh

# User configuration
# See .zshenv for environment

# alias git to hub when the github CLI is installed
if [[ -f $(which hub) ]]; then
    eval $(hub alias -s)
fi

# load completions
if [[ -d ~/.zsh/completions ]]; then
    fpath=(~/.zsh/completions $fpath) 
    autoload -U compinit && compinit
fi

# ssh
function compile-ssh-config() {
    >~/.ssh/config cat <<EOF
# --* This file is automatically generated and overwritten by .zshrc. *--
# --* Put configuration into a file in ~/.ssh/config.d instead. *--
EOF
    for file in ~/.ssh/config.d/*; do
        printf "\n# --- $file ---\n" >> ~/.ssh/config
        cat $file >> ~/.ssh/config
    done
}

function set-mtu() {
  MTU=$(ip li | grep wlan0 | cut -d ' ' -f 5)

  if [[ $MTU != "1200" ]]; then
    print "Setting MTU to 1200..."
    sudo ip li set mtu 1200 dev wlan0
    print $(ip li | grep wlan0 | cut -d ' ' -f 5)
  fi
}

if (( $+commands[ssh] )) && [[ -d ~/.ssh/config.d/ ]]; then
    compile-ssh-config
fi

function mux() {
  #gnome-terminal --window --full-screen --hide-menubar --title=nvim -x sh -c "!!; tmuxinator $1"
  exec alacritty --config-file /home/btburke/projects/dotfiles/alacritty/tmux.yml -e sh -c "tmuxinator $1"&!
  exit 
}


function upgrade-go() {
    LATEST=$(curl -s https://golang.org/dl/ | egrep -o 'go[0-9]\.[0-9]+(\.[0-9]+)?' | head -n 1)
    CURRENT=$(go version | egrep -o '[0-9]+\.[0-9]+\.[0-9]+')
    if [[ $LATEST != $CURRENT ]]; then
        echo "Upgrading from $CURRENT to $LATEST..."
        wget --quiet https://storage.googleapis.com/golang/$LATEST.linux-amd64.tar.gz && sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf $LATEST.linux-amd64.tar.gz && rm $LATEST.linux-amd64.tar.gz && echo "Go version $LATEST installed successfully."
    else
        echo "Version $CURRENT is the latest version of Go"
    fi
}

function upgrade-node() {
    LATEST=$(curl -sL https://nodejs.org/en/download | egrep -o '[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)
    CURRENT=$(node --version | egrep -o '[0-9]+\.[0-9]+\.[0-9]+')
    if [[ $LATEST != $CURRENT ]]; then
        echo "Upgrading from $CURRENT to $LATEST..."
        wget --quiet https://nodejs.org/dist/v$LATEST/node-v$LATEST-linux-x64.tar.xz && sudo rm -rf /usr/local/lib/node/ && sudo mkdir -p /usr/local/lib/node && sudo tar -C /usr/local/lib/node --strip-components=1 -xf node-v$LATEST-linux-x64.tar.xz && rm node-v$LATEST-linux-x64.tar.xz && echo "Node version $LATEST installed successfully."
    else
        echo "Version $CURRENT is the latest version of Node"
    fi
}

function go-monorepo() {
    # check if already in monorepo
    if [[ $MONOENV == true ]]; then 
        echo "It appears you are already in a monorepo environment. Exit first then try again."
        return
    fi

    # check if this looks like a monorepo with a src directory
    if [[ -d src || $(pwd) =~ "src$" ]]; then
        
        # see where we are in dir hierarchy to set root of GOPATH appropriately
        if [[ -d src ]]; then 
            BASE=$(pwd)
        else
            BASE=$(dirname $(pwd))
        fi

        # check if there was a bad teardown before and reset
        if [[ $GOPATH == $BASE ]]; then
            export MONOENV=false
            source ~/.zshenv 
        fi
        
        # if a bad teardown before, blow it away and restart
        if [[ -d $BASE/bin ]]; then
            chmod -R +w $BASE/bin && rm -rf $BASE/bin
        fi
        if [[ -d $BASE/pkg ]]; then
            chmod -R +w $BASE/pkg && rm -rf $BASE/pkg
        fi

        go-tools-update prompt

        # copy existing installed packages in read-only mode, then start new shell with new GOPATH
        mkdir -p $BASE/bin $BASE/pkg && cp -r $GOPATH/bin $BASE && cp -r $GOPATH/pkg $BASE && chmod -R -w $BASE/bin 
        echo "Setting up monorepo env with GOPATH=$BASE"
        MONOENV=true zsh && if [[ -d $BASE/bin ]]; then chmod -R +w $BASE/bin $BASE/pkg && rm -rf $BASE/bin $BASE/pkg; fi && echo "Monorepo tear down.  GOPATH=$GOPATH" || echo "Something went wrong.  Check GOPATH." && export MONOENV=false && source ~/.zshenv
    else
        echo "This doesnt appear to be a valid monorepo.  Run this command from the root of the monorepo."
    fi
}

function go-tools-update() {
    if [[ $# != 0 ]]; then 
        echo -n "Update Go tools? [y/n]: " && read -q UPDATE
        echo " "
        if [[ $UPDATE != "y" ]]; then
            return
        fi
    fi
    if [[ $MONOENV == true ]]; then 
        echo "Cannot update tools while in a monorepo.  Exit and then update."
        return
    fi

    echo "Updating sqlmigrate..."
    go get -u github.com/rubenv/sql-migrate/...

    echo "Updating protoc..."
    PROTOLATEST=$(curl -s https://github.com/google/protobuf/releases | egrep -o 'protoc-([0-9]+\.[0-9]+\.[0-9]+)-linux' | egrep -o '[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)
    PROTOCURRENT=$(protoc --version | egrep -o '[0-9]+\.[0-9]+\.[0-9]+')
    if [[ $PROTOLATEST != $PROTOCURRENT ]]; then
        wget -q -O /tmp/protoc.zip https://github.com/google/protobuf/releases/download/v$PROTOLATEST/protoc-$PROTOLATEST-linux-x86_64.zip && unzip -qq -d /tmp /tmp/protoc.zip && mv /tmp/bin/protoc $GOPATH/bin && rm -rf /tmp/bin /tmp/include /tmp/protoc.zip /tmp/readme.txt
    else
        echo "Proto compiler version $PROTOCURRENT is the latest"
    fi
    go get -u github.com/golang/protobuf/protoc-gen-go

    echo "Updating hub..."
    go get -u github.com/github/hub/

    echo "Updating packr..."
    go get -u github.com/gobuffalo/packr/...

    echo "Updating megacheck..."
    go get -u honnef.co/go/tools/cmd/megacheck

    echo "Updating VS Code tooling..."
    go get -u \
    github.com/ramya-rao-a/go-outline \
    github.com/acroca/go-symbols \
    github.com/visualfc/gocode \
    github.com/rogpeppe/godef \
    golang.org/x/tools/cmd/godoc \
    github.com/zmb3/gogetdoc \
    github.com/golang/lint/golint \
    github.com/fatih/gomodifytags \
    github.com/uudashr/gopkgs/cmd/gopkgs \
    golang.org/x/tools/cmd/gorename \
    sourcegraph.com/sqs/goreturns \
    github.com/cweill/gotests/... \
    golang.org/x/tools/cmd/guru \
    github.com/josharian/impl


}

# The next line updates PATH for the Google Cloud SDK.
#source '/home/btb/google-cloud-sdk/path.zsh.inc'

# The next line enables shell command completion for gcloud.
#source '/home/btb/google-cloud-sdk/completion.zsh.inc'
